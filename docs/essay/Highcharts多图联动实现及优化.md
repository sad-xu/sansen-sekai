# Highcharts多图联动实现及优化

场景: 当前页面内有若干张图表，所有图表的x轴坐标均一致

需求: 
* 同步缩放 - 当对任一图表进行x轴缩放时，所有图表也会一起缩放
* 同步鼠标位置 - 鼠标移至某一图中，所有图表的`准星线`均会随鼠标在图中的位置同步变化

针对以上需求，有一个官方实例`https://jshare.com.cn/temp/YOp6D7`


1. 解读示例实现方法
2. 分析示例的潜在问题和具体优化方案

### 官方示例实现方法

首先，把所有图表的实例存到一个数组中

`allCharts = [chart1, chart2, ...]`

#### 同步缩放

同步缩放比较简单，就两点
* A. 缩放事件 `xAxis.events.setExtremes`
* B. 手动缩放坐标轴 `chart.xAxis[0].setExtremes(min, max, redraw, animation)`

在缩放事件中对其他图表设置同样的范围
用户缩放 --> 触发`A` -> 对其余图表调用`B` --> 被手动设置的图表均会触发`A`

以上会导致死循环
所以要区分用户缩放和`B`引起的缩放，只有在用户缩放触发的事件中才需要执行`B`

在`B`中追加标志

`chart.xAxis[0].setExtremes(min, max, redraw, animation, { trigger: 'syncExtremes' })`

同时在`A`的处理函数中增加判断逻辑 `if (e.trigger === 'syncExtremes')`
即可实现同步缩放

#### 同步鼠标位置

添加`mousemove`事件 --> 得到原生事件的`e` --> 由`e`找到对应图表中的点`point` --> 对`point`设置效果

以下是官方示例的一段代码,关键点有三个
```js
event = chart.pointer.normalize(e.originalEvent) // 1.转换原生事件
point = chart.series[0].searchPoint(event, true) // 2.寻找对应点
if (point) point.highlight(e) // 3.设置`point`效果
```

在所有图表的外层`dom`上绑定了事件，触发时,对所有图表执行以上三步操作

### 官方示例潜在问题及优化

1. 定位不准

若用以上方法实现同步鼠标位置，则每个图表必须`竖直排列`且`首尾对齐`

若图表首尾不对齐或宽度又长又短，则会x轴同步不准

若图表横向排列，则不会出现同步效果

这是示例中最大的缺陷

这时由于示例在事件处理中对每张图都执行了以上三步

即所有图表寻找的对应点都是基于触发事件时的鼠标位置的X坐标，这是一种`视觉角度`

以鼠标位置为基准，画一条竖线

示例只会保证每个图表的准星线都会和竖线重合，导致了以上的问题

解决方法是需要从`数据角度`实现同步
* A. 给每个图表绑定`mousemove`事件
* B. 通过`chart.pointer.normalize`和`chart.series[0].searchPoint`找到当前触发图表的`point`
* C. 由`point`得到x轴实际坐标`x`，遍历其余图表实例在`chart.series[0].data`中根据`x`找到`point`，设置`point`效果

上述方法是靠实际的x轴坐标点实现的定位，可以保证同步时每个图都是同一个坐标
比起示例中每个图都要找点和转换，我的方法只要找一次，遍历只需要`find`即可，节省了大量开销


2. 修改了原型方法

即同步鼠标位置的第三步
```js
Highcharts.Point.prototype.highlight = function (event) {
  this.onMouseOver() // 显示鼠标激活标识
}
```

修改原型方法会对该项目的所有图表产生影响，不应该随便改动
可将第三步改为

```js
point.onMouseOver()
```

3. 性能优化

实例中没有进行任何优化，但多图联动不可避免会出现大量数据的情况，而鼠标事件不可避免的频繁触发也容易导致性能问题

下面将从两个角度谈一谈性能优化

* 配置

可以通过调整highcharts配置进行优化

1. `chart.animation` 
禁用动画效果，减少在渲染上花费的时间

2. `boost.useGPUTranslations`
启用GPU渲染，增加渲染速度

3. `dataGrouping`
当数据量较大时，会进行模糊处理，即相邻数据会合并
虽然会提高性能，但显示精度会明显下降，酌情使用

* js

同样的功能，换一种写法，性能可能会有质的提高

针对js的优化首先是优化逻辑

但在大量数据和图表的情况下，再怎么优化都有很大的计算量

所以就需要欺骗一下人眼了

将大块操作分割成n个小操作，即将大卡顿转化成n个小卡顿

只要单个卡顿耗时小于16ms，对人来说就等于没有卡顿


最开始把所有图表实例存在了一个数组里

之后的许多操作需要遍历数组

这里有两个影响性能的点：数组长度，单次执行时间

假设单次执行耗时为`a`，数组长度为`b`，那么每次循环耗时则为`a*b`

如果按照一般操作，遍历数组的过程中页面是不会进行渲染的

即每次循环会造成`a*b`的卡顿

1. `setTimeout 0`

这是`ECharts`开发者袁源在第三届VueConf中分享的小技巧
通过`setTimeout`0s让浏览器喘口气
将关键性的操作用`setTimeout`包起来

2. 异步

可以把遍历里的操作转成异步，避免产生阻塞

实际开发中往往是异步和`setTimeout`同时使用效果最佳

唯一的副作用是当图表过多时同步效果会有零点几秒的先后差别，这也是没办法的事

* 设计

当用尽手段，效果还是不理想时,就要考虑一下需求的合理性了

是否有必要展示这么多数据,大量的图表是否一定要一起展示，是否可以换一种展现方式


前端在实现一个需求的时候往往要一人分饰三角

开发：如何实现需求 --> 如何更好的实现需求

产品：为什么这样设计 --> 有更好的设计方案吗

用户：使用是否顺心 --> 交互细节是否到位


友情链接：

* [多图联动官方示例](https://jshare.com.cn/temp/YOp6D7)

* [袁源 - Vue开发ECharts踩坑指南演讲视频](https://www.yuque.com/vueconf/2019/blfy0p)
