# 虚假截图与图表的内存泄漏

在 `导出图片和excel实践` 一文中，给出了一个导出图片的方案：

先通过 `html2canvas` 把实际DOM转成canvas，再通过 `file-saver` 把canvas存成图片

这种方式类似截图，在不同尺寸的设备上生成的图片不相同

而且，如果想在生成的图片中做些调整，也无法实现，只能通过 `html2canvas` 隐去指定节点

本文将给出网页截图的升级版实现，并引出图表相关的内存泄漏问题及改动最小的解决方案

## 虚假截图

### 场景

设想一下场景，一个页面，内容是某份报告，包含若干文字段落、表格、图表，有一个导出功能，可以生成当前报告的pdf版本

<!-- 页面结构示意图 -->

直接整屏截取肯定是不太好的，因为生成的样式不好看，文字也不能选中

之所以要前端实现，主要是图表在后端不太好处理，需要服务端渲染，而有些图表不仅仅是传些配置就能画出来的

所以最终的方案是前端只截取图表，把图表部分的截图和其他文字等内容发给后端，在后端拼成pdf

那问题就简化成了：在一个页面截取多个指定区域的图片，且在各个设备生成的图片需要一致

设备不同 -> 页面尺寸不同 -> 截图区域尺寸不同 -> 内部元素布局不同

固定截图区域的宽高，可以解决问题，但不灵活

可以在视口外另外渲染一份尺寸固定的截图区域的内容，对这个克隆体截图，如下

<!-- 克隆体示意图 -->

### 流程

直接上最终的实现逻辑吧

<!-- 逻辑图 -->

流程讲解

### 流程

点击生成按钮，改变 `VUEX` 状态，当前页面若干截图区域 `watch` 状态，触发响应函数

截图区域开始渲染，DOM生成后通知父组件，若有图表，在这时画

调用截图函数，返回 `Promise`，推入队列

队列全部完成后，返回相应数量的图片数据，调接口上传

这里就不放代码了，感觉这个功能应该挺不常用的

### 相关文件

```js
'@/store/modules/app.js'
/*
  generateReportTime 累加
  reportImgList 局部变量 异步队列
  startGenerateReport() 改变状态 + 队列结束处理
  pushReportImg() 推入队列
*/
'@/components/pdf-wrapper'
/*
  通用组件 截图区域包裹
  v-if 控制区域DOM渲染
  监听 this.$store.getters.generateReportTime
  通知父组件 this.$emit('generateStart')
  调用截图方法并推入队列 this.$store.dispatch('app/pushReportImg', p)
  结束后销毁自身，同时通知父组件 this.$emit('generateEnd)
*/
'@/utils/export'
/*
  截图方法
  html2canvas 指定DOM渲染
  双重 import 调用时才加载资源
*/
```

### 特点

* 截图内容不会因网页尺寸而变形

* 可截出和实际内容不一致的图片内容，代价是截图区域的模板代码翻倍

* 使用 `VUEX`，无需层层事件通知，逻辑清晰

### 使用

1. 触发开始生成

```js
this.$store.dispatch('app/startGenerateReport')
```

2. 使用 `pdf-wrapper` 组件包裹

为了生成的图片与网页尺寸无关，需要将截图内容复制到组件插槽内，复制内容初始默认不渲染

若有图表，需要改变 `id`，如 `#chart` -> `#chart-pdf`，同时，修改画图函数，增加 `id` 参数

组件DOM首次渲染完成时，触发 `generateStart` 事件，在这里画复制内容里的图标

截图结束后，触发 `generateEnd` 事件，若有图表，在这里调用 `chart.destory()` 销毁，防止内存泄漏


## 内存泄漏

### 截图区域的内存泄漏

用以上方式实现后，测试了几下，发现每次截图后的内存都会涨上一截，并且无法被回收

<!-- 如图 -->

截图区域的组件我是手动销毁了的，内存泄漏的可能不是图表的问题就是 `html2canvas` 的问题

试试没有图表的情况

<!-- 图 -->

那就是额外生成的图表需要手动销毁一下

可以在 `pdf-wrapper` 销毁前向外发送通知，有图表的父组件收到时销毁

### 图表的内存泄漏

这时有一个疑问，Highcharts 的文档里对 `destroy` 方法的解释是这样的

`destroy(): Remove the chart and purge memory. This method is called internally before adding a second chart into the same container, as well as on window unload to prevent leaks.`

中文文档是这样写的

`删除图表并释放内存。推荐在对同一个容器生成新的图表时先调用此函数来销毁该容器对应的图表对象。当窗口（Windows 对象）有内存泄漏时该函数会在图表内部被调用（即内部会调用此函数用于内存防止内存泄漏）。`

那么在单页应用中，不加页面缓存，先生成了一个图表，切换到其他页面，此时那个图表的内存会不会被自动回收？

### 测试

做个测试，有一个tab页，包含两个标签，点击可以切换动态组件，不缓存，每个组件里都有图表

先手动GC -> 切换2轮标签页 -> 手动GC -> 切换2轮标签页 -> 手动GC

<!-- 看下性能图 -->

可以看到内存一直在上升，GC完全不起作用，生成一张图表会涨1M左右内存，这要是在图表多的页面，岂不是分分钟上百

在组件销毁前手动调用 `destroy()`

<!-- 性能图 -->

目前来看内存泄漏的问题

原因是创建的图表没有被销毁

解决方法是在图表所在的组件销毁前，手动销毁图表

看起来很完美

下面是需要增加的代码

<!-- code -->

每个有图表的文件都要加上这些，我是不能忍受的

### 最小改动的解决方案

如何用最小的改动解决这个问题呢？

现在必须要用到是 `beforeDestroy`

不妨加个全局 `beforeDestroy` 钩子

怎么拿到图表实例呢，`Highcharts.charts` 存有所有创建过的图表对象

那么问题来了，怎么找到当前销毁的组件里的图表对象？

图表实例里会有一些DOM节点的引用，除了这个，图表与组件似乎没有其他联系了

没有联系可以建立联系嘛

每个 Vue 组件都有一个自增的唯一的 `_uid`，位于源码 `https://github.com/vuejs/vue/blob/dev/src/core/instance/init.js#L19`

在初始化图表时，新增一个同样的字段 `_uid`

在钩子函数里这样写

```js
Vue.mixin({
  beforeDestroy() {
    const UID = this._uid
    Highcharts.charts.forEach(chart => {
      if (chart && chart.userOptions._uid === UID) {
        chart.destroy()
      }
    })
  }
})
```

这样一来，每个文件里就只需要增加两行代码

```js
const that = this
// Highcharts.chart(this.$el.querySelector('#chart'), {
// ...
    _uid: that._uid
// ...
// })
```

从十来行减少到两行，完美




### 事实

不光是克隆区域，所有的图表都没有被回收


1. Menory - snapshot - filter:detached

2. 分辨率 DPI
